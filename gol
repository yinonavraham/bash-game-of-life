#!/usr/bin/env bash

board_rows=20
board_cols=20

# http://www.fileformat.info/info/unicode/block/block_elements/images.htm
BLOCK_FULL='\xE2\x96\x88'
BLOCK_LIGHT_SHADE='\xE2\x96\x91'

function cell_alive() {
  local row="${1}"
  local col="${2}"
  local cell_name
  cell_name="$(cell_var_name "${row}" "${col}")"
  [[ "${!cell_name}" == true ]]
}

function set_cell_alive() {
  local row="${1}"
  local col="${2}"
  local alive="${3}"
  local cell_name
  cell_name="$(cell_var_name "${row}" "${col}")"
  export "${cell_name}=${alive}"
}

function cell_var_name() {
  local row="${1}"
  local col="${2}"
  echo "board_${row}_${col}"
}

function cell_should_live() {
  local row="${1}"
  local col="${2}"
  local neighbors=0
  local r c
  for ((r = row-1; r <= row+1; r++)); do
  	[[ "${r}" -ge 0 ]] && [[ "${r}" -lt "${board_rows}" ]] || continue
    for ((c = col-1; c <= col+1; c++)); do
  	  [[ "${c}" -ge 0 ]] && [[ "${c}" -lt "${board_cols}" ]] || continue
  	  if [[ "${r}" == "${row}" ]] && [[ "${c}" == "${col}" ]]; then continue; fi
  	  if cell_alive "${r}" "${c}"; then
  	  	neighbors=$((neighbors + 1))
  	  fi
  	done
  done
  if cell_alive "${row}" "${col}"; then
    [[ "${neighbors}" -eq 3 ]] || [[ "${neighbors}" -eq 2 ]]
  else
  	[[ "${neighbors}" -eq 3 ]]
  fi 
}

function update_board_next_lifecycle() {
  local row col newboard_cell_name cell_name ctrlFile updatedCellsFile threads=0 offset length
  updatedCellsFile="$(mktemp)"
  ctrlFile="$(mktemp)"
  for ((row = 0; row < board_rows; row++)); do
  	offset=0
  	while [[ "$((board_cols - offset))" -gt 0 ]]; do
  	  length=10 # Each thread will handle an array of size 10
  	  if [[ "$((offset + length))" -gt "${board_cols}" ]]; then
  	    length="$((board_cols - offset))"
  	  fi
      update_board_row_next_lifecycle "${row}" "${offset}" "${length}" "${updatedCellsFile}" "${ctrlFile}" &
      threads=$((threads + 1))
      offset=$((offset + length))
    done
  done
  waitForThreads "${ctrlFile}" "${threads}"
  while read line; do
    ${line}
  done < "${updatedCellsFile}"
  rm -rf "${updatedCellsFile}"
}

function update_board_row_next_lifecycle() {
  local row="${1}"
  local colStart="${2}"
  local colLength="${3}"
  local updatedCellsFile="${4}"
  local ctrlFile="${5}"
  local col cell_name
  for ((col = colStart; col < colStart+colLength; col++)); do
  	cell_name="$(cell_var_name "${row}" "${col}")"
    if cell_should_live "${row}" "${col}"; then
      if ! cell_alive "${row}" "${col}"; then
        echo "export ${cell_name}=true" >> "${updatedCellsFile}"
      fi
    elif cell_alive "${row}" "${col}"; then
      echo "export ${cell_name}=false" >> "${updatedCellsFile}"
    fi
  done
  echo "${row}" >> "${ctrlFile}"
}

function waitForThreads() {
  local ctrlFile="${1}"
  local threadCount="${2}"
  while ! controlFileComplete "${ctrlFile}" "${threadCount}"; do
  	sleep 0.1
  done
  rm -rf "${ctrlFile}"
}

function controlFileComplete() {
  local ctrlFile="${1}"
  local expectedCount="${2}"
  if [[ ! -f "${ctrlFile}" ]]; then
  	return 1
  fi
  local count
  count="$(wc -l "${ctrlFile}" | sed 's/^ *//g' | sed 's/  *.*//g')"
  [[ "${count}" -ge "${expectedCount}" ]]
}

function run_life() {
  while true; do
  	#sleep 0.1
  	update_board_next_lifecycle
  	print_board
  done
}

function init_board() {
  local r c
  for ((r = 0; r < board_rows; r++)); do
    for ((c = 0; c < board_cols; c++)); do
  	  set_cell_alive "${r}" "${c}" false
  	done
  done
}

function print_board() {
  clear
  local r c block cell_name
  for ((r = 0; r < board_rows; r++)); do
    for ((c = 0; c < board_cols; c++)); do
      block="${BLOCK_LIGHT_SHADE}"
  	  if cell_alive "${r}" "${c}"; then
  	  	block="${BLOCK_FULL}"
      fi
      printf "${block}${block}"
  	done
  	printf "\n"
  done
}

init_board
set_cell_alive 8 10 true
set_cell_alive 9 8 true
set_cell_alive 9 10 true
set_cell_alive 10 9 true
set_cell_alive 10 10 true
print_board
run_life